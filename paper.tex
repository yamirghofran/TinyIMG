\documentclass{article}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}

\title{Mathematical Foundations of TinyImg: \\
A WebAssembly-Powered Image Transformation Framework}
\author{Yousef Amirghofran \and Lea Aboujaoude \and Anze Zgonc \and Boris Gans \and Hala Amr Yaghi \and Georgios Klonis}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
This paper presents the mathematical foundations of TinyImg, a high-performance image processing framework that leverages WebAssembly for efficient computation in web browsers. We explore the linear algebra principles underlying image transformations, the implementation of homogeneous coordinates for affine transformations, and the numerical methods used for pixel interpolation. The framework demonstrates how classical mathematical concepts in computer graphics can be efficiently implemented using modern web technologies, bridging the gap between theoretical foundations and practical applications.
\end{abstract}

\section{Introduction}

Digital image processing relies heavily on mathematical transformations to manipulate visual data. The TinyImg framework implements these transformations using a combination of C code compiled to WebAssembly and a React-based user interface. This paper focuses on the mathematical principles that form the foundation of the framework's image transformation capabilities.

The core mathematical concepts implemented in TinyImg include:

\begin{itemize}
    \item Homogeneous coordinates and transformation matrices
    \item Affine transformations (rotation, scaling, flipping, shearing)
    \item Matrix composition for combined transformations
    \item Bilinear interpolation for pixel mapping
\end{itemize}

We demonstrate how these concepts are implemented efficiently in a web environment using WebAssembly, providing both theoretical background and practical implementation details.

\section{Homogeneous Coordinates and Transformation Matrices}

\subsection{Homogeneous Coordinates}

In TinyImg, we use homogeneous coordinates to represent points in 2D space. This representation allows us to express affine transformations (such as rotation, scaling, and translation) as matrix multiplications.

A point $(x, y)$ in Cartesian coordinates is represented as $(x, y, 1)$ in homogeneous coordinates. This additional coordinate enables us to represent translations as matrix multiplications rather than vector additions.

\subsection{Transformation Matrix Structure}

The framework uses $3 \times 3$ matrices to represent transformations:

\begin{equation}
T = \begin{bmatrix}
a & b & c \\
d & e & f \\
0 & 0 & 1
\end{bmatrix}
\end{equation}

Where:
\begin{itemize}
    \item $a, b, d, e$ control rotation, scaling, and shearing
    \item $c, f$ control translation
    \item The bottom row $[0, 0, 1]$ is fixed for affine transformations
\end{itemize}

When this matrix is applied to a point in homogeneous coordinates, it transforms the point according to:

\begin{equation}
\begin{bmatrix}
x' \\
y' \\
1
\end{bmatrix} = 
\begin{bmatrix}
a & b & c \\
d & e & f \\
0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
1
\end{bmatrix} = 
\begin{bmatrix}
ax + by + c \\
dx + ey + f \\
1
\end{bmatrix}
\end{equation}

\section{Basic Transformation Matrices}

\subsection{Identity Matrix}

The identity matrix represents no transformation and serves as the starting point for building more complex transformations:

\begin{equation}
I = \begin{bmatrix}
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{bmatrix}
\end{equation}

In TinyImg, this is implemented in the \texttt{createIdentityMatrix()} function.

\subsection{Rotation Matrix}

Rotation by an angle $\theta$ around the origin is represented by:

\begin{equation}
R(\theta) = \begin{bmatrix}
\cos(\theta) & -\sin(\theta) & 0 \\
\sin(\theta) & \cos(\theta) & 0 \\
0 & 0 & 1
\end{bmatrix}
\end{equation}

The framework converts angles from degrees to radians using $\theta_{rad} = \theta_{deg} \times \frac{\pi}{180}$ before computing the trigonometric functions.

\subsection{Scaling Matrix}

Scaling by factors $s_x$ and $s_y$ along the x and y axes is represented by:

\begin{equation}
S(s_x, s_y) = \begin{bmatrix}
s_x & 0 & 0 \\
0 & s_y & 0 \\
0 & 0 & 1
\end{bmatrix}
\end{equation}

This allows for uniform scaling ($s_x = s_y$) or non-uniform scaling ($s_x \neq s_y$).

\subsection{Flip Matrix}

Flipping (mirroring) an image horizontally or vertically is represented by:

\begin{equation}
F(h, v) = \begin{bmatrix}
(-1)^h & 0 & 0 \\
0 & (-1)^v & 0 \\
0 & 0 & 1
\end{bmatrix}
\end{equation}

Where $h$ and $v$ are boolean values indicating horizontal and vertical flipping, respectively.

\subsection{Shear Matrix}

Shearing (warping) an image by factors $k_x$ and $k_y$ is represented by:

\begin{equation}
W(k_x, k_y) = \begin{bmatrix}
1 & k_x & 0 \\
k_y & 1 & 0 \\
0 & 0 & 1
\end{bmatrix}
\end{equation}

This transformation skews the image horizontally by $k_x$ and vertically by $k_y$.

\section{Matrix Composition}

One of the key advantages of using transformation matrices is the ability to combine multiple transformations through matrix multiplication. If $T_1$ and $T_2$ are transformation matrices, then applying $T_1$ followed by $T_2$ is equivalent to applying the composite transformation $T_2 \times T_1$.

In TinyImg, matrix multiplication is implemented as:

\begin{equation}
(T_2 \times T_1)_{ij} = \sum_{k=1}^{3} (T_2)_{ik} \times (T_1)_{kj}
\end{equation}

The order of transformations is crucial. In the framework, transformations are applied in the following order:
\begin{enumerate}
    \item Shearing
    \item Flipping
    \item Scaling
    \item Rotation
\end{enumerate}

This order is chosen to provide intuitive behavior for users while maintaining mathematical correctness.

\section{Pixel Mapping and Interpolation}

\subsection{Inverse Transformation}

When transforming an image, we need to determine the color of each pixel in the output image. Rather than mapping each input pixel to the output (which could leave gaps), we use the inverse approach: for each output pixel, we find the corresponding position in the input image.

Given a transformation matrix $T$, we compute its inverse $T^{-1}$ and use it to map output coordinates back to input coordinates:

\begin{equation}
\begin{bmatrix}
x_{in} \\
y_{in} \\
1
\end{bmatrix} = 
T^{-1}
\begin{bmatrix}
x_{out} \\
y_{out} \\
1
\end{bmatrix}
\end{equation}

For a $2 \times 2$ submatrix of $T$:
\begin{equation}
A = \begin{bmatrix}
a & b \\
c & d
\end{bmatrix}
\end{equation}

The inverse is computed as:
\begin{equation}
A^{-1} = \frac{1}{\det(A)} \begin{bmatrix}
d & -b \\
-c & a
\end{bmatrix}
\end{equation}

where $\det(A) = ad - bc$.

\subsection{Bilinear Interpolation}

Since the mapped coordinates $(x_{in}, y_{in})$ are typically not integer values, we need to interpolate between the surrounding pixels. TinyImg uses bilinear interpolation for this purpose.

Given a point $(x, y)$ with non-integer coordinates, we identify the four surrounding pixels:
\begin{align}
(x_0, y_0) &= (\lfloor x \rfloor, \lfloor y \rfloor) \\
(x_1, y_0) &= (\lfloor x \rfloor + 1, \lfloor y \rfloor) \\
(x_0, y_1) &= (\lfloor x \rfloor, \lfloor y \rfloor + 1) \\
(x_1, y_1) &= (\lfloor x \rfloor + 1, \lfloor y \rfloor + 1)
\end{align}

Let $f(x,y)$ represent the pixel value at coordinates $(x,y)$. The interpolated value is:

\begin{equation}
\begin{split}
f(x,y) &= (1-\alpha)(1-\beta)f(x_0,y_0) + \alpha(1-\beta)f(x_1,y_0) \\
&+ (1-\alpha)\beta f(x_0,y_1) + \alpha\beta f(x_1,y_1)
\end{split}
\end{equation}

where $\alpha = x - x_0$ and $\beta = y - y_0$ are the fractional parts of the coordinates.

This interpolation is performed separately for each color channel (R, G, B, A) to produce the final pixel value.

\section{Implementation in WebAssembly}

The mathematical operations described above are implemented in C and compiled to WebAssembly for efficient execution in web browsers. This approach combines the performance benefits of compiled code with the accessibility of web applications.

\subsection{Memory Management}

The framework uses explicit memory management to handle image data efficiently:

\begin{algorithm}
\caption{Image Transformation Process}
\begin{algorithmic}[1]
\State Allocate memory for input image matrix
\State Copy image data from JavaScript to WebAssembly memory
\State Create transformation matrix
\State Apply transformation using inverse mapping and bilinear interpolation
\State Copy result back to JavaScript
\State Free allocated memory
\end{algorithmic}
\end{algorithm}

\subsection{Performance Considerations}

Several mathematical optimizations are employed to improve performance:

\begin{itemize}
    \item Pre-computing the inverse transformation matrix once per transformation
    \item Using integer arithmetic where possible
    \item Optimizing memory access patterns for cache efficiency
    \item Avoiding redundant calculations in the interpolation process
\end{itemize}

\section{Conclusion}

The TinyImg framework demonstrates how classical mathematical concepts in computer graphics can be efficiently implemented using modern web technologies. By leveraging WebAssembly for performance-critical mathematical operations, the framework achieves near-native performance while maintaining the accessibility of web applications.

The mathematical foundations described in this paper—homogeneous coordinates, transformation matrices, and bilinear interpolation—form the basis for a wide range of image processing operations. These concepts, while well-established in computer graphics literature, find new applications in the context of web-based image processing.

Future work could extend these mathematical foundations to include more advanced transformations, such as perspective projections, non-linear warping, and color space transformations. Additionally, the framework could be extended to support operations on 3D data, opening up possibilities for web-based 3D modeling and visualization.

\section{References}

\end{document}